#! /usr/bin/env python3


"""
COMP3311
23T1
Assignment 2
Pokemon Database

Written by: <YOUR NAME HERE> <YOUR STUDENT ID HERE>
Written on: <DATE HERE>

My Pokemon

Create your very own Pokemon
"""


import sys
import psycopg2
import helpers
from random import Random


### Constants
USAGE = f"Usage: {sys.argv[0]} <Seed>"


### Globals
db = None
Seed = None
rng = None


### Command-line args
if len(sys.argv) != 2:
    print(USAGE, file=sys.stderr)
Seed = int(sys.argv[1]) # read the seed from the command line
rng  = Random(Seed)     # set the seed for the python random number generator

# `rng` is a python Random number generator
# `rng.random()` returns a random float between 0 and 1
# `rng.randint(a, b)` returns a random integer between a and b (inclusive)

# `SELECT setseed(seed);` sets the postgres random seed to `seed`
# `SELECT * FROM Table ORDER BY random() LIMIT 5;` gives 5 random rows from the table `Table`
# `SELECT setseed(seed);` should be used once, before any calls to random(), with the a random number generated by `rng.random()`

def menu(items: list[str]) -> int:
    """
    Given a list of strings,
    print a numbered menu
    and return the user's selection.
    """
    padding = len(str(len(items)))
    print(f"Select an option from the menu below by entering its number:")
    for i, item in enumerate(items):
        print(f"{i+1:{padding}}) {item}")
    ret = int(input("> Selection: ")) - 1
    if not sys.stdin.isatty():
        print(f"{ret+1}")
    print()
    return ret


def main():
    # TODO: YOUR CODE
    

    cur = db.cursor()
    cur.execute("select setseed(%s);", [rng.random()])
    
    # Select Game
    gameList = []
    gameSelect = '''
    select name from games order by random() limit 10;
    '''
    cur.execute(gameSelect)
    
    for tuple in cur.fetchall():
        gameList.append(tuple[0])

    gameSelection = menu(gameList)

    # Select Pokemon from game
    pmList = []
    pmSelect = '''
    select 
        pm.name 
    from 
        pokemon pm,
        games g,
        pokedex pd
    where
        g.name = %s
        and
        pm.id = pd.national_ID
        and
        pd.game = g.id
    order by random()
    limit 10;
    '''

    cur.execute(pmSelect, (gameList[gameSelection],))

    for tuple in cur.fetchall():
        pmList.append(tuple[0])

    pmSelection = menu(pmList)

    # Select Pokemon ability
    abilityList = []
    abilitySelect = '''
    select
        a.name
    from
        pokemon pm,
        abilities a,
        knowable_abilities ka
    where
        pm.name = %s
        and
        ka.known_by = pm.id
        and
        a.id = ka.knows
    order by a.id;
    '''

    cur.execute(abilitySelect, (pmList[pmSelection],))
    
    for tuple in cur.fetchall():
        abilityList.append(tuple[0])
    
    if len(abilityList) > 0:
        abilitySelection = menu(abilityList)

    # Select move
    moveList = []
    moveSelect = '''
    select distinct
        m.name
    from
        pokemon pm
        left join
        learnable_moves lm on lm.learnt_by = pm.id
        left join
        moves m on m.id = lm.learns
        left join
        games g on g.id = lm.learnt_in
    where
        pm.name = %s
        and
        lm.learnt_when < 99
        and
        g.name = %s
    order by m.name;
    '''
    
    cur.execute(moveSelect, (pmList[pmSelection], gameList[gameSelection],))
    
    for tuple in cur.fetchall():
        moveList.append(tuple[0])
    
    learntMoves = []

    while len(moveList) > 0 and len(learntMoves) < 4:
        moveSelection = menu(moveList)
        learntMoves.append(moveList[moveSelection])
        moveList.remove(moveList[moveSelection])

    # Formatting

    print(f'Here is your new Pokemon (from Pokemon {gameList[gameSelection]})\n')
    print(f'Name: {pmList[pmSelection]}')

    speciesSelect = '''
    select
        pm.species
    from
        pokemon pm
    where
        pm.name = %s;
    '''
    cur.execute(speciesSelect, (pmList[pmSelection],))
    print(f'Species: {cur.fetchone()[0]}')

    typeSelect = '''
    select
        t.name
    from
        types t
        join
        pokemon pm on pm.first_type = t.id
    where
        pm.name = %s
    '''
    cur.execute(typeSelect, (pmList[pmSelection],))
    type1 = cur.fetchone()[0]

    typeSelect2 = '''
    select
        t.name
    from
        types t
        join
        pokemon pm on pm.second_type = t.id
    where
        pm.name = %s
    '''
    cur.execute(typeSelect2, (pmList[pmSelection],))
    
    type2 = cur.fetchone()

    if type2 is not None:
        type2 = type2[0]
    else:
        type2 = None
    
    if type2 is not None:
        print(f'Type: {type1} + {type2} ')
    else:
        print(f'Type: {type1}')

    pokedexSelect = '''
    select
        pd.regional_id,
        pd.national_id
    from
        pokedex pd,
        pokemon pm
    where
        pd.national_id = pm.id
        and
        pm.name = %s;
    '''
    cur.execute(pokedexSelect, (pmList[pmSelection],))
    index = cur.fetchone()
    regionalID = index[0]
    nationalID = index[1]
    nationalID = nationalID.replace(",","")
    nationalID = nationalID[:-2]
    print(f'Pokedex Number: {regionalID} {nationalID})\n')
    
    # Abilities
    if len(abilityList) > 0:
        print(f'Ability: {abilityList[abilitySelection]}\n')
    else:
        print("Ability: None\n")
        
    # Moves
    print('Moves:')
    
    for move in learntMoves:
        cur.execute('''select t.name, m.category, m.power, m.accuracy from types t, moves m where m.name = %s;''', (move,))
        typeList = cur.fetchall()[0]
        
        moveType = typeList[1]
        tCategory = typeList[1]
        tPower = typeList[2]
        tAccuracy = typeList[3]

        print(f'\t{move} [{moveType}] (Category: {tCategory}, Power: {tPower}, Accuracy: {tAccuracy})') 
        
    print('')
    ... 



if __name__ == '__main__':
    try:
        db = psycopg2.connect(dbname="ass2")
        main()
    except psycopg2.Error as err:
        print("DB error: ", err)
    except Exception as err:
        print("Internal Error: ", err)
        raise err
    finally:
        if db is not None:
            db.close()
    sys.exit(0)